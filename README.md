# PubSub-сервис

## Описание сервиса

PubSub-сервис представляет собой gRPC-сервер, реализующий механизм публикации и подписки на сообщения по ключу. Сервис позволяет клиентам подписываться на определенные темы (ключи) и получать сообщения, опубликованные другими клиентами по этим ключам.

### Основные возможности:

- **Подписка на сообщения**: Клиенты могут подписываться на сообщения по определенному ключу и получать поток событий через gRPC-стрим.
- **Публикация сообщений**: Клиенты могут публиковать сообщения по ключу, которые будут доставлены всем подписчикам этого ключа.
- **Масштабируемость**: Сервис использует пул воркеров для обработки сообщений, что обеспечивает эффективную работу при высокой нагрузке.
- **Конфигурируемость**: Различные параметры сервиса (порт, количество воркеров, размер очереди и т.д.) могут быть настроены через переменные окружения.

## Архитектура

Сервис построен с использованием следующих компонентов:

1. **gRPC-сервер**: Обрабатывает запросы клиентов на подписку и публикацию сообщений.
2. **PubSub-механизм**: Реализует логику публикации и подписки с использованием пула воркеров.
3. **Адаптер**: Связывает gRPC-интерфейс с внутренней реализацией PubSub.

Реализация PubSub в сервисе обеспечивает полную потокобезопасность, что позволяет безопасно использовать его в многопоточной среде. Механизмы обеспечения потокобезопасности включают:

1. **Синхронизация доступа к данным**:
   - Использование `sync.RWMutex` для защиты карты подписчиков от одновременного доступа из разных горутин
   - Применение блокировок чтения (`RLock`) при операциях, не изменяющих состояние (например, при публикации сообщений)
   - Применение блокировок записи (`Lock`) при операциях, изменяющих состояние (например, при подписке/отписке)

2. **Пул воркеров**:
   - Обработка сообщений выполняется в отдельных горутинах-воркерах
   - Количество воркеров настраивается через параметр `WORKER_COUNT`
   - Воркеры получают задания через буферизованный канал, что обеспечивает равномерное распределение нагрузки

3. **Очередь сообщений**:
   - Использование буферизованного канала для очереди сообщений
   - Размер очереди настраивается через параметр `QUEUE_SIZE`
   - При переполнении очереди операции публикации блокируются до освобождения места

4. **Безопасное завершение работы**:
   - Использование `sync.WaitGroup` для отслеживания активных задач
   - Корректное закрытие каналов при завершении работы
   - Ожидание завершения всех активных задач перед полной остановкой сервиса

5. **Атомарные операции подписки/отписки**:
   - Каждая подписка получает уникальный идентификатор (UUID)
   - Операции отписки выполняются атомарно и не влияют на другие подписки
   - Замыкания (closures) используются для инкапсуляции логики отписки

Такая реализация позволяет сервису эффективно обрабатывать множество одновременных подписок и публикаций без риска состояния гонки (race condition) или взаимных блокировок (deadlocks).

## Сборка и запуск

### Предварительные требования

- Go 1.23 или выше
- Docker и Docker Compose (для запуска в контейнере)
- Protobuf компилятор (для генерации кода из .proto файлов)

### Сборка из исходного кода

1. Клонируйте репозиторий:
   ```
   git clone <URL репозитория>
   cd <директория репозитория>
   ```

2. Соберите приложение:
   ```
   go build -o server ./cmd/api
   ```

3. Запустите сервер:
   ```
   ./server
   ```

### Запуск с использованием Docker

1. Соберите и запустите контейнер с помощью Docker Compose:
   ```
   docker-compose up -d
   ```

## Конфигурация

Сервис может быть настроен с помощью переменных окружения. Создайте файл `.env` в корне проекта или передайте переменные окружения напрямую.

### Доступные параметры:

| Параметр | Описание | Значение по умолчанию |
|----------|----------|------------------------|
| GRPC_PORT | Порт для gRPC-сервера | 50051 |
| ENABLE_REFLECTION | Включение рефлексии gRPC (полезно для отладки) | true |
| WORKER_COUNT | Количество воркеров для обработки сообщений | 5 |
| QUEUE_SIZE | Размер очереди сообщений | 100 |

Пример файла `.env`:
```
GRPC_PORT=50051
ENABLE_REFLECTION=true
WORKER_COUNT=10
QUEUE_SIZE=200
```

## Логирование

Сервис использует стандартный пакет `log` из Go для логирования. Логи включают:

- Информацию о запуске сервера
- Ошибки при обработке запросов
- Информацию о завершении работы сервера

Примеры логов:
```
grpc server listening on port 50051
shutting down server...
grpc server stopped
```

## Использованные паттерны и практики

### Паттерны проектирования:

1. **Dependency Injection (Внедрение зависимостей)**: Сервис использует внедрение зависимостей для передачи компонентов, что упрощает тестирование и замену реализаций.

2. **Adapter (Адаптер)**: Используется для адаптации общего интерфейса PubSub к конкретной реализации сервиса.

3. **Options Pattern (Паттерн опций)**: Применяется для конфигурирования компонентов с использованием функциональных опций.

4. **Worker Pool (Пул воркеров)**: Используется для эффективной обработки сообщений в многопоточной среде.

### Практики микросервисной разработки:

1. **Graceful Shutdown (Корректное завершение работы)**: Сервис корректно завершает работу при получении сигналов SIGTERM или SIGINT, завершая все текущие операции.

2. **Configuration via Environment Variables (Конфигурация через переменные окружения)**: Параметры сервиса настраиваются через переменные окружения, что соответствует принципам 12-факторного приложения.

3. **Containerization (Контейнеризация)**: Сервис упакован в Docker-контейнер, что обеспечивает изоляцию и упрощает развертывание.

4. **Multi-stage Builds (Многоэтапные сборки)**: Dockerfile использует многоэтапную сборку для минимизации размера итогового образа.

5. **Minimal Base Image (Минимальный базовый образ)**: Использование Alpine Linux в качестве базового образа для минимизации размера и уязвимостей.

6. **Non-root User (Непривилегированный пользователь)**: Сервис запускается от имени непривилегированного пользователя для повышения безопасности.

## API

Сервис предоставляет gRPC API, определенное в файле `api/sub_pub/sub_pub.proto`:

### Методы:

1. **Subscribe**: Подписка на сообщения по ключу.
   ```protobuf
   rpc Subscribe(SubscribeRequest) returns (stream Event);
   ```

2. **Publish**: Публикация сообщения по ключу.
   ```protobuf
   rpc Publish(PublishRequest) returns (google.protobuf.Empty);
   ```

### Сообщения:

1. **SubscribeRequest**: Запрос на подписку.
   ```protobuf
   message SubscribeRequest {
     string key = 1;
   }
   ```

2. **PublishRequest**: Запрос на публикацию.
   ```protobuf
   message PublishRequest {
     string key  = 1;
     string data = 2;
   }
   ```

3. **Event**: Событие, отправляемое подписчикам.
   ```protobuf
   message Event {
     string data = 1;
   }
   ```

## Примеры использования

### Подписка на сообщения

```go
conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
if err != nil {
    log.Fatalf("не удалось подключиться: %v", err)
}
defer conn.Close()

client := pb.NewPubSubClient(conn)
stream, err := client.Subscribe(context.Background(), &pb.SubscribeRequest{Key: "my-topic"})
if err != nil {
    log.Fatalf("ошибка подписки: %v", err)
}

for {
    event, err := stream.Recv()
    if err == io.EOF {
        break
    }
    if err != nil {
        log.Fatalf("ошибка получения сообщения: %v", err)
    }
    log.Printf("Получено сообщение: %s", event.Data)
}
```

### Публикация сообщений

```go
conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
if err != nil {
    log.Fatalf("не удалось подключиться: %v", err)
}
defer conn.Close()

client := pb.NewPubSubClient(conn)
_, err = client.Publish(context.Background(), &pb.PublishRequest{
    Key:  "my-topic",
    Data: "Привет, мир!",
})
if err != nil {
    log.Fatalf("ошибка публикации: %v", err)
}
log.Println("Сообщение опубликовано")
```